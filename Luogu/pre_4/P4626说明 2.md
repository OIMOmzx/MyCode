### Part 0 前言

[LOJ上的原题](https://loj.ac/p/6165)。

如果不懂线性筛的知识点，请先学习 [P3383 线性筛模板
](https://www.luogu.com.cn/problem/P3383)。

此题考查质数的线性筛，看似很基础，但是，~~我却写了一个多小时~~。希望能过审~

### Part 1 前置知识

这道题，放在小学奥数中，我们常常使用 $lcm(1, 2, ..., n)$，但是考虑到循环的时间复杂度为 $O(n)$，而 $lcm$ 的实现靠 $\gcd$ 函数的递归调用，所以复杂度在 $O(n^2)$，显然过不了这道题目，于是我们不妨不单单从数的角度去看这个问题，我们可以从因数的方向看待这个问题，于是我们可以导出我们这题的一个前置知识点：唯一分解定理。

- 唯一分解定理：对于任何一个大于 1 的自然数 $N$，如果 $N$ 不为质数，那么 $N$ 可以唯一分解成有限个质数的乘积，$N=P_1^{a_1}P_2^{a_2}P_3^{a_3}...P_n^{a_n}$，这里 $P_1<P_2<P_3......<P_n$ 均为质数，其中指数 $a_i \in N+$。这样的分解称为 $N$ 的标准分解式。最早证明是由欧几里得给出的，由陈述证明。此定理可推广至更一般的交换代数和代数数论。于是，这个定理可以证明我们下面讲的欧氏筛的完全性，代码中也会用到。


### Part 2 思路

我们不妨先看到样例，当 $n = 10$ 时，我们以答案举例，我们会发现 $2520 = 2^3 \times 3^2 \times 5 \times 7$ 根据~~小学奥数~~教过的知识点，我们知道，只要找到一个小于等于 $n$ 的质因子 $k$，那么最终答案中的 $k$ 的指数为 $log_k(n)$ ，和~~小学的~~勒让德定理有一点点相似（虽然没有半毛钱关系）。

所以，我们可以自己先把所有的质因子全部筛出来，然后再算次数，最后边乘便 mod 1e8 + 7 即可。我们来复习一下素数筛法。

- Eratosthenes（埃氏）筛法，时间复杂度 $O(Nlog_{log_N} )$：
	1. 每次扫描一个数，把这个数的倍数标记为合数（非素数）。
	2. 对于 例如 2 和 3 都会把 6 标记为合数的情况，有：小于 $ x^2$ 的 $x$ 的倍数在扫描更小的数时都会已经被标记为合数。因此，对于每个数 $x$，我们只需要从 $x^2$ 开始，把 $x^2$, $( x + 1 ) \times x$ , . . . , $[ n \div x ] \times x$ 标记为合数即可。

- Euler（欧式线性）筛法：时间复杂度 $O(N)$：
	1. Eratosthenes 筛法即使在优化后任会重复标记合数。例如 12 既会被 2 又会被 3 标记。根本原因在于没有唯一确定出产生数 12 的方式。
	2. 欧式线性筛法通过“从大到小累积质因子”的方式标记每个合数，例如让 12 只有 $3 × 2 × 2$。在 2 的时候已经被确定不为质数，所以就可以退出。这里是我们的实现过程：

		依次考虑 $2-n$ 之间的每个数 $i$。

		若 $vis [i] = 0$，说明 $i$ 是质数，把它保存下来。

		之后，把 $i$ 这个数的所有小于等于它的质数倍全部标为 1，即不为质数。于是，最终我们可以知道总有一刻，会发现这个数已经被标记了，这时我们就可以不用再循环遍历下去了，直接退出第二个循环。比如，6，在 2 的时候已经表明过，而到 3 的时候，可以确定 6 已经在一个比 3 小质因子时标记过了，于是退出，这里**非常重要**。

有点晕，对吧，那让我们来看欧式筛的一个片段：

```cpp
    for(int i = 2; i <= n; i++)//从 2 到 n 循环遍历质数
    {
        if(vis[i] == 0) prime[cnt] = i, cnt++;
        //如果没有标记不为质数，那就是质数，记录
        for(int j = 0; j < cnt && i * prime[j] <= n; j++)
        {
            vis[i * prime[j]] = 1;//上文已经讲解
            if(i % prime[j] == 0) break;//这里是重点
        }
    }

```
最终，我们只需要求出每个质因子的个数，边乘边 mod 1e8+7，即可。

### Part 3 Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 100000007;
int prime[100000010];
bool vis[100000010];//数组开大一点
int main()
{
    unsigned long long n, cnt = 0;
    cin >> n;
    for(int i = 2; i <= n; i++)//从 2 到 n 循环遍历质数
    {
        if(vis[i] == 0) prime[cnt] = i, cnt++;
        //如果没有标记不为质数，那就是质数，记录
        for(int j = 0; j < cnt && i * prime[j] <= n; j++)
        {
            vis[i * prime[j]] = 1;//上文已经讲解
            if(i % prime[j] == 0) break;//这里是重点
        }
    }
    unsigned long long ans = 1;
    //记录最终答案的乘积
    for(int i = 0; i < cnt; i++)
    {
        unsigned long long tmp = prime[i];
        prime[i] %= mod;
        while(tmp <= n)
        {
            tmp *= prime[i];
        }
        if(tmp != n) tmp /= prime[i];
        //不能整除的时候需要除以一个 prime[i]，因为最终在最后一次循环的时候会多一次
        ans *= tmp;
        //tmp 在这里是代替的是 log 的作用
        ans %= mod;
    }
    cout << ans;
    return 0;
}
```

### Part 4 AC
[O2，1.91s，119.38MB](https://www.luogu.com.cn/record/57877957)
